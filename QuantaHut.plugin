"""
Library for Quanta Plugins
Also a big thanks to @zwyPlugins, We took some code snippets/methods from zwylib
"""

import json
import time
import copy
import threading
import traceback
import os.path
from typing import List, Callable, Optional, Any
from dataclasses import dataclass

from base_plugin import BasePlugin
from android_utils import log, run_on_ui_thread
from client_utils import get_messages_controller, send_request, get_file_loader
from ui.settings import Divider, Header, Switch, Input, Text
from ui.bulletin import BulletinHelper

from org.telegram.messenger import Utilities, FileLoader
from org.telegram.tgnet import TLRPC
from com.exteragram.messenger.utils import ChatUtils
from java import dynamic_proxy, cast, jclass
from java.util import ArrayList
from java.lang import Integer
from org.telegram.messenger import MessageObject, R
from org.telegram.ui import ChatActivity

__name__ = "QuantaHut"
__description__ = "Library for Quanta plugins"
__icon__ = "luvztroyIcons/14"
__id__ = "quantahut"
__version__ = "1.2.0"
__author__ = "@luvztroy"
__min_version__ = "11.12.1"
__priority__ = 1

CUSTOM_EMOJI_CONFIG = {}

FILE_LOADER_CHANNEL_ID = 2549292030
FILE_LOADER_CHANNEL_USERNAME = "Quantalibrary"
EMOJI_CONFIG_MESSAGE_ID = 34

class QuantaHut(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hook_refs = []

    def get_custom_emoji_id(self, chat_id: int):
        return CUSTOM_EMOJI_CONFIG.get(chat_id)
    
    def log(self, message: str):
        if self.get_setting("show_logs", DEFAULT_SHOW_LOGS):
            log(f"[QuantaHut] {message}")
    
    def fetch_emoji_config(self):
        try:
            self.log("Fetching emoji configuration...")
            add_file_loader_task(__id__, FILE_LOADER_CHANNEL_ID, FILE_LOADER_CHANNEL_USERNAME, 0, EMOJI_CONFIG_MESSAGE_ID)
        except Exception as e:
            self.log(f"Error fetching emoji config: {str(e)}")
    
    def update_emoji_config(self, config_data: dict):
        try:
            CUSTOM_EMOJI_CONFIG.update(config_data)
            self.log(f"Updated emoji config with {len(config_data)} entries")
        except Exception as e:
            self.log(f"Error updating emoji config: {str(e)}")

    def create_settings(self):
        return [
            Header(text="QuantaHut Configuration"),
            Switch(
                key="show_logs",
                text="Enable Debug Logging",
                subtext="Display detailed QuantaHut operation logs",
                default=DEFAULT_SHOW_LOGS,
                icon="menu_intro_solar",
            ),
            Divider(),
            Text(
                text="Clear File Cache",
                red=True,
                on_click=self._clear_file_cache,
                icon="msg_delete",
            ),
        ]

    def on_plugin_load(self):
        self.log("Initializing QuantaHut...")
        global file_loader_core, setting_getter
        setting_getter = self.get_setting

        file_loader_core = QuantaHutCore()
        
        self.setup_hooks()
        
        def run_background_tasks():
            try:
                cache_key = f"{__id__}_en"
                if cache_key in file_loader_core.file_cache.content:
                    cached_data = file_loader_core.file_cache.content[cache_key]
                    if isinstance(cached_data, dict):
                        converted_data = {}
                        for key, value in cached_data.items():
                            try:
                                converted_data[int(key)] = value
                            except (ValueError, TypeError):
                                pass
                        CUSTOM_EMOJI_CONFIG.update(converted_data)
                        self.log(f"Restored {len(converted_data)} emoji config entries from cache")
                
                load_cached_file_loader_tasks(wipe=True)
                
                if not hasattr(self, '_cache_cleared'):
                    file_loader_tasks_cache.wipe()
                    self._cache_cleared = True
                
                self.fetch_emoji_config()
                self._reload_dependent_plugins()
            except Exception as e:
                self.log(f"Error in background tasks: {str(e)}")
                traceback.print_exc()
        
        background_thread = threading.Thread(target=run_background_tasks)
        background_thread.daemon = True
        background_thread.start()

    def setup_hooks(self):
        try:
            _ensure_message_menu_hooks(self)
            self._setup_emoji_hooks()
        except Exception as e:
            self.log(f"setup_hooks error: {str(e)}")

    def _reload_dependent_plugins(self):
        try:
            pass
        except Exception as e:
            self.log(f"Error reloading plugins: {str(e)}")

    def _clear_file_cache(self, view):
        try:
            if file_loader_core and hasattr(file_loader_core, 'file_cache'):
                cache_size_before = len(file_loader_core.file_cache.content)
                file_loader_core.file_cache.wipe()
                cache_size_after = len(file_loader_core.file_cache.content)
                self.log(f"Cache cleared: {cache_size_before} -> {cache_size_after} entries")
                
                run_on_ui_thread(lambda: BulletinHelper.show_success("File cache cleared successfully"))
            else:
                self.log("Failed to clear cache - QuantaHut not ready")
                run_on_ui_thread(lambda: BulletinHelper.show_error("Failed to clear cache - QuantaHut not ready"))
        except Exception as e:
            self.log(f"Error clearing cache: {str(e)}")
            traceback.print_exc()
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Error clearing cache: {str(e)}"))

    def register_message_context_menu_item(self, *args, **kwargs):
        return utilities.register_message_menu_item(*args, **kwargs)

    def unregister_message_context_menu_item(self, handle):
        return utilities.unregister_message_menu_item(handle)

    def _setup_emoji_hooks(self):
        try:
            from hook_utils import find_class, get_private_field, set_private_field
            from java import jclass
            
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if ChatActivity:
                Boolean = jclass("java.lang.Boolean")
                method = ChatActivity.getClass().getDeclaredMethod("updateTitle", Boolean.TYPE)
                method.setAccessible(True)
                
                class ChatActivityEmojiHook:
                    def __init__(self, plugin):
                        self.plugin = plugin
                        self._last_update = {}
                        self._processed_activities = set()
                    
                    def after_hooked_method(self, param):
                        try:
                            chat_activity = param.thisObject
                            activity_id = id(chat_activity)
                            current_time = time.time()
                            if activity_id in self._processed_activities and current_time - self._last_update.get(activity_id, 0) < 0.3:
                                return
                            
                            current_chat = get_private_field(chat_activity, "currentChat")
                            current_user = get_private_field(chat_activity, "currentUser")
         
                            chat_id = None
                            if current_chat:
                                chat_id = current_chat.id
                            elif current_user:
                                chat_id = current_user.id
                            
                            if chat_id:
                                emoji_id = self.plugin.get_custom_emoji_id(chat_id)
                                if not emoji_id:
                                    emoji_id = self.plugin.get_custom_emoji_id(-chat_id)
                                if emoji_id:
                                    avatar_container = get_private_field(chat_activity, "avatarContainer")
                                    if avatar_container:
                                        emoji_drawable = get_private_field(avatar_container, "emojiStatusDrawable")
                                        if emoji_drawable:
                                            emoji_drawable.set(emoji_id, False)
                                            emoji_drawable.setParticles(True, False)
                                            avatar_container.setTitleIcons(None, emoji_drawable)
                                            
                                            self._processed_activities.add(activity_id)
                                            self._last_update[activity_id] = current_time
                                            if len(self._processed_activities) > 50:
                                                old_activities = [aid for aid, t in self._last_update.items() if current_time - t > 2.0]
                                                for old_activity in old_activities:
                                                    self._processed_activities.discard(old_activity)
                                                    self._last_update.pop(old_activity, None)
                                    
                        except Exception as e:
                            pass
                
                ref = self.hook_method(method, ChatActivityEmojiHook(self))
                self.hook_refs.append(ref)
            
            DialogCell = find_class("org.telegram.ui.Cells.DialogCell")
            if DialogCell:
                method = DialogCell.getClass().getDeclaredMethod("buildLayout")
                method.setAccessible(True)
                
                class DialogCellEmojiHook:
                    def __init__(self, plugin):
                        self.plugin = plugin
                        self._last_update = {}
                        self._processed_cells = set()
                    
                    def after_hooked_method(self, param):
                        try:
                            dialog_cell = param.thisObject
                            cell_id = id(dialog_cell)
                            current_time = time.time()
                            if cell_id in self._processed_cells and current_time - self._last_update.get(cell_id, 0) < 0.2:
                                return
                            
                            current_dialog_id = get_private_field(dialog_cell, "currentDialogId")
                            
                            if current_dialog_id:
                                target_id = -current_dialog_id if current_dialog_id < 0 else current_dialog_id
                                emoji_id = self.plugin.get_custom_emoji_id(target_id)
                                if not emoji_id and current_dialog_id < 0:
                                    emoji_id = self.plugin.get_custom_emoji_id(current_dialog_id)
                                if emoji_id:
                                    emoji_status = get_private_field(dialog_cell, "emojiStatus")
                                    if emoji_status:
                                        current_emoji = get_private_field(emoji_status, "currentDocumentId")
                                        if current_emoji != emoji_id:
                                            emoji_status.set(emoji_id, False)
                                            emoji_status.setParticles(True, False)
                                            set_private_field(dialog_cell, "drawPremium", True)
                                            set_private_field(dialog_cell, "nameLayoutEllipsizeByGradient", True)
                                            
                                            self._processed_cells.add(cell_id)
                                            self._last_update[cell_id] = current_time
                                            if len(self._processed_cells) > 100:
                                                old_cells = [cid for cid, t in self._last_update.items() if current_time - t > 1.0]
                                                for old_cell in old_cells:
                                                    self._processed_cells.discard(old_cell)
                                                    self._last_update.pop(old_cell, None)
                        except Exception as e:
                            pass
                
                ref = self.hook_method(method, DialogCellEmojiHook(self))
                self.hook_refs.append(ref)
            
            ChatMessageCell = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if ChatMessageCell:
                method = ChatMessageCell.getClass().getDeclaredMethod("getAuthorStatus")
                method.setAccessible(True)
                
                class ChatMessageCellEmojiHook:
                    def __init__(self, plugin):
                        self.plugin = plugin
                    
                    def before_hooked_method(self, param):
                        try:
                            message_cell = param.thisObject
                            current_user = get_private_field(message_cell, "currentUser")
                            
                            if current_user and hasattr(current_user, 'id'):
                                user_id = current_user.id
                                emoji_id = self.plugin.get_custom_emoji_id(user_id)
                                if emoji_id:
                                    param.setResult(emoji_id)
                        except Exception as e:
                            pass
                
                ref = self.hook_method(method, ChatMessageCellEmojiHook(self))
                self.hook_refs.append(ref)
            
            ProfileActivity = find_class("org.telegram.ui.ProfileActivity")
            if ProfileActivity:
                method = ProfileActivity.getClass().getDeclaredMethod("updateProfileData", jclass("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                
                class ProfileActivityEmojiHook:
                    def __init__(self, plugin):
                        self.plugin = plugin
                    
                    def after_hooked_method(self, param):
                        try:
                            profile_activity = param.thisObject
                            user_id = get_private_field(profile_activity, "userId")
                            chat_id = get_private_field(profile_activity, "chatId")
                            
                            target_id = user_id if user_id > 0 else -chat_id if chat_id > 0 else None
                            if target_id:
                                emoji_id = self.plugin.get_custom_emoji_id(target_id)
                                if emoji_id:
                                    name_text_view = get_private_field(profile_activity, "nameTextView")
                                    emoji_status_drawable = get_private_field(profile_activity, "emojiStatusDrawable")
                                    
                                    from org.telegram.ui.Components import AnimatedEmojiDrawable
                                    from org.telegram.messenger import AndroidUtilities
                                    from android_utils import OnClickListener
                                    from ui.bulletin import BulletinHelper
                                    from android_utils import run_on_ui_thread
                                    from client_utils import get_messages_controller
                                    
                                    if emoji_status_drawable[0] is None:
                                        emoji_status_drawable[0] = AnimatedEmojiDrawable.SwapAnimatedEmojiDrawable(name_text_view[0], AndroidUtilities.dp(24), 0)
                                    
                                    if emoji_status_drawable[1] is None:
                                        emoji_status_drawable[1] = AnimatedEmojiDrawable.SwapAnimatedEmojiDrawable(name_text_view[1], AndroidUtilities.dp(24), 1)
                                    
                                    emoji_status_drawable[0].set(emoji_id, False)
                                    emoji_status_drawable[0].setParticles(True, False)
                                    name_text_view[0].setRightDrawable(emoji_status_drawable[0])
                                    
                                    emoji_status_drawable[1].set(emoji_id, False)
                                    emoji_status_drawable[1].setParticles(True, False)
                                    name_text_view[1].setRightDrawable(emoji_status_drawable[1])
                                    
                                    def show_emoji_bulletin(view=None):
                                        if target_id > 0:
                                            user = get_messages_controller().getUser(target_id)
                                            first_name = getattr(user, 'first_name', '') or ''
                                            last_name = getattr(user, 'last_name', '') or ''
                                            full_name = f"{first_name} {last_name}".strip()
                                            message = f"{full_name} is a member of the Quanta development team."
                                        else:
                                            chat = get_messages_controller().getChat(abs(target_id))
                                            chat_title = getattr(chat, 'title', '')
                                            message = f"{chat_title} is the official resource of Quanta."
                                        
                                        from org.telegram.ui.Components import AnimatedEmojiDrawable
                                        emoji_drawable = AnimatedEmojiDrawable.SwapAnimatedEmojiDrawable(None, AndroidUtilities.dp(32), 0)
                                        emoji_drawable.set(emoji_id, False)
                                        run_on_ui_thread(lambda: BulletinHelper.show_simple(message, emoji_drawable))
                                    
                                    name_text_view[0].setRightDrawableOnClick(OnClickListener(show_emoji_bulletin))
                                    name_text_view[1].setRightDrawableOnClick(OnClickListener(show_emoji_bulletin))
                        except Exception as e:
                            pass
                
                ref = self.hook_method(method, ProfileActivityEmojiHook(self))
                self.hook_refs.append(ref)
                
        except Exception as e:
            self.log(f"Error setting up emoji hooks: {str(e)}")

    def on_plugin_unload(self):
        for ref in self.hook_refs:
            if ref:
                try:
                    self.unhook_method(ref)
                except:
                    pass
        self.hook_refs.clear()
        
        self.log("Plugin unloading, clearing cache...")
        cache_all_file_loader_tasks(wipe=True)


@dataclass
class FileLoaderTask:
    plugin_id: str
    channel_id: int
    channel_username: str
    message_id: int
    file_message_id: int = 0


class JsonCacheFile:
    cache_dir_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")

    def __init__(self, filename: str, default: Any, read_on_init = True):
        self.filename = filename
        self.path = os.path.join(JsonCacheFile.cache_dir_name, filename)
        self.content = copy.copy(default)
        self.default = copy.copy(default)

        os.makedirs(JsonCacheFile.cache_dir_name, exist_ok=True)

        if read_on_init:
            self.read()

    def read(self) -> Any:
        try:
            with open(self.path) as file:
                self.content = json.load(file)
        except (json.JSONDecodeError, FileNotFoundError):
            self.wipe()
            return self.default
        else:
            return self.content

    def write(self):
        try:
            with open(self.path, "w") as file:
                json.dump(self.content, file)
        except PermissionError:
            quantahut_log("Permission error writing cache")
        except Exception as e:
            quantahut_log(f"Error writing cache: {str(e)}")

    def wipe(self):
        old_size = len(self.content)
        self.content = copy.copy(self.default)
        self.write()


class Callback1(dynamic_proxy(Utilities.Callback)):
    def __init__(self, fn: Callable[[Any], None]):
        super().__init__()
        self._fn = fn

    def run(self, arg):
        try:
            self._fn(arg)
        except Exception as e:
            quantahut_log(f"Callback error: {str(e)}")


class QuantaHutCore:
    def __init__(self):
        self.file_cache = JsonCacheFile("quantahut_files", {})

    def log(self, message: str):
        quantahut_log(message)

    def get_localization(self, plugin_id: str, key: str, default: str = None) -> str:
        try:
            from org.telegram.messenger import LocaleController
            locale_controller = LocaleController.getInstance()
            current_language = locale_controller.getCurrentLocaleInfo().getLangCode()
        except Exception as e:
            current_language = "en"
        
        if current_language == "en":
            return default or key
        
        cache_key = f"{plugin_id}_{current_language}"
        
        if cache_key in self.file_cache.content:
            plugin_data = self.file_cache.content[cache_key]
            result = plugin_data.get(key, default or key)
            return result
        
        plugin_data = self.file_cache.content.get(plugin_id, {})
        result = plugin_data.get(key, default or key)
        return result

    def add_localization(self, plugin_id: str, key: str, value: str):
        try:
            cache_key = f"{plugin_id}_{key}"
            self.file_cache.content[cache_key] = value
            self.file_cache.write()
        except Exception as e:
            quantahut_log(f"Error adding localization: {str(e)}")

    def add_task(self, task: FileLoaderTask):
        if task.file_message_id > 0:
            self.fetch_file_sync(task.plugin_id, task)
        return True

    def remove_task_by_id(self, plugin_id: str):
        pass

    def fetch_file_sync(self, plugin_id: str, task: FileLoaderTask):
        if task.file_message_id == 0:
            return
        
        try:
            from org.telegram.messenger import LocaleController
            locale_controller = LocaleController.getInstance()
            current_language = locale_controller.getCurrentLocaleInfo().getLangCode()
        except Exception as e:
            current_language = "en"

        if current_language == "en" and plugin_id != __id__:
            return

        cache_key = f"{plugin_id}_{current_language}"
        cache_metadata_key = f"{plugin_id}_{current_language}_metadata"
        
        has_cached_data = cache_key in self.file_cache.content
        has_cached_metadata = cache_metadata_key in self.file_cache.content
        
        if has_cached_data and has_cached_metadata:
            cached_metadata = self.file_cache.content[cache_metadata_key]
            cached_edit_date = cached_metadata.get("edit_date", 0)

        target_message_id = task.file_message_id
        
        try:
            result_received = threading.Event()
            file_data = {}
            
            def file_callback(response, error):
                nonlocal file_data
                if error is not None or response is None:
                    quantahut_log(f"File callback error: {error}")
                    result_received.set()
                    return

                for msg_id in [target_message_id]:
                    msg = get_message(response, msg_id)
                    if msg and msg.media:
                        break
                else:
                    result_received.set()
                    return
                
                try:
                    document = msg.media.getDocument()
                    if not document:
                        result_received.set()
                        return

                    current_edit_date = getattr(msg, 'edit_date', 0)
                    quantahut_log(f"Message edit status check - Plugin: {plugin_id}, Current edit date: {current_edit_date}, Cached edit date: {cached_edit_date if has_cached_data and has_cached_metadata else 'N/A'}")
                    
                    if has_cached_data and has_cached_metadata:
                        if current_edit_date == cached_edit_date:
                            quantahut_log(f"No changes detected in localization message - Plugin: {plugin_id}, using cached data")
                            result_received.set()
                            return
                        else:
                            quantahut_log(f"Localization message has been edited - Plugin: {plugin_id}, fetching updated data")
                    
                    from client_utils import get_file_loader
                    file_loader = get_file_loader()
                    path = file_loader.getPathToAttach(document, True)

                    if path.exists():
                        with open(str(path), 'r', encoding='utf-8') as f:
                            file_data = json.load(f)
                            
                            self.file_cache.content[cache_key] = file_data
                            
                            metadata = {
                                "edit_date": current_edit_date,
                                "message_id": msg.id,
                                "cached_at": int(time.time()),
                                "file_size": len(file_data)
                            }
                            self.file_cache.content[cache_metadata_key] = metadata
                            self.file_cache.write()
                            
                            if plugin_id == __id__ and target_message_id == EMOJI_CONFIG_MESSAGE_ID:
                                try:
                                    converted_data = {}
                                    for key, value in file_data.items():
                                        try:
                                            converted_data[int(key)] = value
                                        except (ValueError, TypeError):
                                            pass
                                    CUSTOM_EMOJI_CONFIG.update(converted_data)
                                except Exception as e:
                                    quantahut_log(f"Error updating emoji config: {str(e)}")
                    else:
                        try:
                            file_loader.loadFile(document, "file_update", FileLoader.PRIORITY_NORMAL, 1)
                            
                            alt_path = file_loader.getPathToAttach(document, False)
                            start_time = time.time()
                            file_found = False
                            
                            while time.time() - start_time < 30 and not file_found:
                                if path.exists():
                                    file_found = True
                                    break
                                elif alt_path.exists():
                                    file_found = True
                                    break
                                time.sleep(1)
                            
                            if file_found:
                                final_path = path if path.exists() else alt_path
                                
                                with open(str(final_path), 'r', encoding='utf-8') as f:
                                    file_data = json.load(f)
                                    
                                    self.file_cache.content[cache_key] = file_data
                                    
                                    metadata = {
                                        "edit_date": current_edit_date,
                                        "message_id": msg.id,
                                        "cached_at": int(time.time()),
                                        "file_size": len(file_data)
                                    }
                                    self.file_cache.content[cache_metadata_key] = metadata
                                    self.file_cache.write()
                                    
                                    if plugin_id == __id__ and target_message_id == EMOJI_CONFIG_MESSAGE_ID:
                                        try:
                                            converted_data = {}
                                            for key, value in file_data.items():
                                                try:
                                                    converted_data[int(key)] = value
                                                except (ValueError, TypeError):
                                                    pass
                                            CUSTOM_EMOJI_CONFIG.update(converted_data)
                                        except Exception as e:
                                            quantahut_log(f"Error updating emoji config: {str(e)}")
                        except Exception as e:
                            quantahut_log(f"Error downloading file: {str(e)}")
                            
                except Exception as e:
                    quantahut_log(f"Error processing file data: {str(e)}")
                    traceback.print_exc()
                finally:
                    result_received.set()
                
            get_messages(task.channel_id, task.channel_username, file_callback)
            
            if result_received.wait(timeout=30):
                pass
            else:
                quantahut_log(f"File fetch timed out")
            
        except Exception as e:
            quantahut_log(f"Error in file fetch: {str(e)}")
            traceback.print_exc()


file_loader_core: Optional[QuantaHutCore] = None
setting_getter: Optional[Callable] = None
file_loader_tasks_cache = JsonCacheFile("quantahut_file_loader_tasks", [])

DEFAULT_SHOW_LOGS = False

def quantahut_log(message: str):
    if setting_getter and setting_getter("show_logs", DEFAULT_SHOW_LOGS):
        log(f"[QuantaHut] {message}")


def get_message(messages, message_id):
    if not messages:
        return None
    
    if hasattr(messages, 'messages'):
        iterator = messages.messages.iterator()
        
        while iterator.hasNext():
            msg = iterator.next()
            
            if msg.id == message_id:
                return msg
        
        return None


def get_messages(channel_id: int, channel_username: str, callback):
    def get_message_callback(response, error):
        if error or not response:
            callback(None, error)
            return

        messages = cast(TLRPC.messages_Messages, response)
        callback(messages, None)

    def send():
        send_request(req, get_message_callback)

    def channel_resolve_callback(arg):
        if arg is not None and arg.id == channel_id:
            req.peer = TLRPC.TL_inputPeerChannel()
            req.peer.channel_id = arg.id
            req.peer.access_hash = arg.access_hash
            run_on_ui_thread(send)
            return

    req = TLRPC.TL_messages_getHistory()
    req.peer = get_messages_controller().getInputPeer(channel_id)
    req.offset_id = 0
    req.limit = 50

    if req.peer.access_hash == 0:
        clean_username = channel_username.lstrip('@')
        ChatUtils.getInstance().resolveChannel(clean_username, Callback1(channel_resolve_callback))
    else:
        run_on_ui_thread(send)


def add_file_loader_task(plugin_id: str, channel_id: int, channel_username: str, message_id: int, file_message_id: int = 0):
    if file_loader_core is None:
        if not hasattr(add_file_loader_task, '_pending_tasks'):
            add_file_loader_task._pending_tasks = []
        
        pending_task = {
            'plugin_id': plugin_id,
            'channel_id': channel_id,
            'channel_username': channel_username,
            'message_id': message_id,
            'file_message_id': file_message_id
        }
        add_file_loader_task._pending_tasks.append(pending_task)
        return True

    task = FileLoaderTask(plugin_id, channel_id, channel_username, message_id, file_message_id)
    
    def run_file_loader_check():
        try:
            file_loader_core.add_task(task)
        except Exception as e:
            quantahut_log(f"Error in file loader check: {str(e)}")
            traceback.print_exc()
    
    try:
        file_loader_thread = threading.Thread(target=run_file_loader_check)
        file_loader_thread.daemon = True
        file_loader_thread.start()
    except Exception as e:
        quantahut_log(f"Error starting file loader thread: {str(e)}")
        
    return True


def process_pending_file_loader_tasks():
    if not hasattr(add_file_loader_task, '_pending_tasks'):
        return
    
    if file_loader_core is None:
        return
    
    pending_tasks = add_file_loader_task._pending_tasks.copy()
    add_file_loader_task._pending_tasks.clear()
    
    for task_data in pending_tasks:
        try:
            add_file_loader_task(
                task_data['plugin_id'],
                task_data['channel_id'],
                task_data['channel_username'],
                task_data['message_id'],
                task_data['file_message_id']
            )
        except Exception as e:
            quantahut_log(f"Error processing pending task: {str(e)}")


def get_localized_string(plugin_id: str, key: str, default: str = None) -> str:
    if file_loader_core is None:
        return default or key
    
    result = file_loader_core.get_localization(plugin_id, key, default)
    return result


def remove_file_loader_task(plugin_id: str):
    if file_loader_core is None:
        return

    file_loader_core.remove_task_by_id(plugin_id)


def cache_all_file_loader_tasks(wipe: bool):
    if wipe:
        file_loader_tasks_cache.wipe()


def load_cached_file_loader_tasks(wipe: bool):
    if wipe:
        file_loader_tasks_cache.wipe()


__all__ = ("add_file_loader_task", "remove_file_loader_task", "get_localized_string", "JsonCacheFile", "utilities", "hut")


class _MessageMenuRegistry:
    def __init__(self):
        self.items = []
        self._unhook_fill = None
        self._unhook_process = None

    def ensure_hooks(self, plugin: BasePlugin):
        try:
            if not self._unhook_fill:
                fill_method = ChatActivity.getClass().getDeclaredMethod(
                    "fillMessageMenu",
                    MessageObject,
                    ArrayList,
                    ArrayList,
                    ArrayList
                )
                self._unhook_fill = plugin.hook_method(fill_method, _QHFillMenuHook(self))
        except Exception as e:
            quantahut_log(f"fillMessageMenu hook error: {str(e)}")
        try:
            if not self._unhook_process:
                process_method = ChatActivity.getClass().getDeclaredMethod(
                    "processSelectedOption",
                    Integer.TYPE
                )
                self._unhook_process = plugin.hook_method(process_method, _QHProcessOptionHook(self))
        except Exception as e:
            quantahut_log(f"processSelectedOption hook error: {str(e)}")

    def register_item(self, *, text: str, option_id: int, icon_res: int, condition_predicate, on_click, insert_at_top: bool):
        handle = {
            'text': text,
            'option_id': int(option_id),
            'icon_res': int(icon_res),
            'condition': condition_predicate,
            'on_click': on_click,
            'insert_top': bool(insert_at_top),
        }
        self.items.append(handle)
        return handle

    def unregister_item(self, handle):
        try:
            if handle in self.items:
                self.items.remove(handle)
        except Exception:
            pass


class _QHFillMenuHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        pass

    def after_hooked_method(self, param):
        try:
            primary = param.args[0]
            if primary is None:
                return
            try:
                self.registry.last_message = primary
            except Exception:
                pass
            icons = param.args[1]
            items = param.args[2]
            options = param.args[3]

            for entry in list(self.registry.items):
                try:
                    if entry.get('condition') and callable(entry['condition']):
                        if not entry['condition'](primary):
                            continue
                    if entry.get('insert_top'):
                        icons.add(0, Integer(entry['icon_res']))
                        options.add(0, Integer(entry['option_id']))
                        items.add(0, entry['text'])
                    else:
                        icons.add(Integer(entry['icon_res']))
                        options.add(Integer(entry['option_id']))
                        items.add(entry['text'])
                except Exception:
                    continue
        except Exception:
            pass


class _QHProcessOptionHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        try:
            option = param.args[0]
            try:
                opt_val = int(option)
            except Exception:
                try:
                    opt_val = option.intValue()
                except Exception:
                    return

            for entry in list(self.registry.items):
                if opt_val == entry.get('option_id'):
                    try:
                        chat_activity = param.thisObject
                        message = getattr(chat_activity, 'selectedObject', None)
                        if message is None:
                            message = getattr(self.registry, 'last_message', None)
                        try:
                            chat_activity.closeMenu()
                        except Exception:
                            pass
                        if callable(entry.get('on_click')):
                            entry['on_click'](chat_activity, message)
                        param.setResult(None)
                    except Exception:
                        pass
                    finally:
                        return
        except Exception:
            pass

    def after_hooked_method(self, param):
        pass


_message_menu_registry = _MessageMenuRegistry()


def _ensure_message_menu_hooks(plugin: BasePlugin):
    _message_menu_registry.ensure_hooks(plugin)


class HutUtilities:
    def register_message_menu_item(self, *, text: str, option_id: int, icon_res: int = R.drawable.msg_message_s, condition_predicate=None, on_click=None, insert_at_top: bool = False):
        try:
            return _message_menu_registry.register_item(
                text=text,
                option_id=option_id,
                icon_res=icon_res,
                condition_predicate=condition_predicate,
                on_click=on_click,
                insert_at_top=insert_at_top,
            )
        except Exception as e:
            quantahut_log(f"utilities.register_message_menu_item error: {str(e)}")
            return None

    def unregister_message_menu_item(self, handle):
        try:
            if handle:
                _message_menu_registry.unregister_item(handle)
        except Exception as e:
            quantahut_log(f"utilities.unregister_message_menu_item error: {str(e)}")


utilities = HutUtilities()
hut = utilities
